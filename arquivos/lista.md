<h1 align="center">üìã TAD - Lista</h1>
<p align="center">üéØ <strong>Estrutura Sequencial Linear Abstrata</strong></p>
<p align="center">‚ö†Ô∏è Permite inser√ß√µes, remo√ß√µes e acessos em posi√ß√µes arbitr√°rias.</p>

## üîß Opera√ß√µes Principais
* `insertFirst(object)` ‚Üí Insere um elemento no **in√≠cio**.
* `insertLast(object)` ‚Üí Insere um elemento no **final**.
* `insertAfter(object, object)` ‚Üí Insere elemento **depois** de outro elemento.
* `insertBefore(object, object)` ‚Üí Insere um elemento **antes** de outro elemento.
* `object replaceElement(object, object)` ‚Üí Substitui um **elemento antigo** por um **elemento novo**.
* `swapElement(object, object)` ‚Üí Troca de posi√ß√£o de um elemento com outro elemento.
* `object remove(object)` ‚Üí Remove e retorna um elemento.

## üß∞ Opera√ß√µes Auxiliares
* `object first()` ‚Üí Retorna o **primeiro elemento**.
* `object last()` ‚Üí Retorna o **√∫ltimo elemento**.
* `boolean inFirst(object)` ‚Üí Verifica se o elemento est√° na **primeira posi√ß√£o**.
* `boolean inLast(object)` ‚Üí Verifica se o elemento est√° na **√∫ltima posi√ß√£o**.
* `object after(object)` ‚Üí Retorna um elemento **posterior** a outro elemento.
* `object before(object)` ‚Üí Retorna um elemento **anterior** a outro elemento.
* `interger size()` ‚Üí Retorna o **n√∫mero de elementos** na lista.
* `boolean isEmpty()` ‚Üí Verifica se a lista est√° **vazia**.
* `object search(object)` ‚Üí Retorna o **elemento** se ele existir.

<br>

## ‚ö†Ô∏è Exce√ß√µes

* **ENaoEncontrado:** Elemento n√£o encontrado durante o `search()`.
* **EListaVazia:** Tentativa de remo√ß√£o, troca ou retorno com a lista vazia.

<br>

## üõ†Ô∏è Exemplos Pr√°ticos

* Editor de texto (inser√ß√£o/remo√ß√£o no meio de par√°grafos)
* Listas de reprodu√ß√£o (playlists)
* Navega√ß√£o (voltar/avan√ßar em hist√≥rico)
* Gerenciadores de tarefas encadeadas

<br>

## üß± Implementa√ß√£o Usando Lista **Duplamente Ligada**

> Cada n√≥ possui refer√™ncias para o **n√≥ anterior** e o **n√≥ seguinte**, permitindo navega√ß√£o bidirecional. A estrutura √© iniciada com **n√≥s sentinelas**: `Head` e `Tail`.

### üîß Estrutura B√°sica

```text
Head <-> [A] <-> [B] <-> [C] <-> Tail
```

* `Head` aponta para o primeiro n√≥ **real** da lista.
* `Tail` √© apontado pelo √∫ltimo n√≥ **real** da lista.
* A estrutura evita `null` como marcador de fim/in√≠cio.
* Cada n√≥ armazena:
  * `Elemento`
  * `Anterior`
  * `Pr√≥ximo`

<br>

### ‚öôÔ∏è Modo de Funcionamento

* `Head.After()` retorna o primeiro n√≥ **v√°lido** da lista (ou `Tail` se vazia).
* `Tail.Before()` retorna o √∫ltimo n√≥ **v√°lido**.
* Inser√ß√µes entre dois n√≥s s√£o feitas atualizando **dois ponteiros**:
  * `novo.Anterior = anterior`
  * `novo.Proximo = seguinte`
* Remo√ß√µes eliminam o n√≥ ajustando os ponteiros dos vizinhos.

> ‚ö†Ô∏è Como a lista √© bidirecional, **n√£o √© necess√°rio percorrer** desde o in√≠cio para obter o elemento anterior (`Before()`).

<br>

### ‚úÖ Vantagens

* Acesso eficiente para `Before()` e `After()` ‚Üí **O(1)**
* Navega√ß√£o **nos dois sentidos**
* Inser√ß√µes e remo√ß√µes s√£o mais diretas, com menos necessidade de itera√ß√£o
* Ideal para **estruturas sequenciais complexas** e **opera√ß√µes de edi√ß√£o**

<br>

### ‚ùå Limita√ß√µes

* Consome mais **mem√≥ria**, pois cada n√≥ armazena dois ponteiros.
* A implementa√ß√£o √© **mais detalhada**, com cuidados extras para manter a consist√™ncia dos v√≠nculos.

<br>

### ‚úèÔ∏è Implementa√ß√£o em C#
```csharp
using System;

class ListaVaziaExcecao : Exception                 // Classe de Exce√ß√£o de Lista Vazia
{
    public ListaVaziaExcecao() : base("A Lista est√° vazia!") {}
    public ListaVaziaExcecao(string mensagem) : base(mensagem) {}
    public ListaVaziaExcecao(string mensagem, Exception inner) : base(mensagem, inner) {}
}

class ObjetoNaoEncontradoExcecao : Exception         // Classe de Exce√ß√£o de Objeto n√£o Encontrado na Lista
{
    public ObjetoNaoEncontradoExcecao() : base("Objeto n√£o foi encontrado na Lista!") {}
    public ObjetoNaoEncontradoExcecao(string mensagem) : base(mensagem) {}
    public ObjetoNaoEncontradoExcecao(string mensagem, Exception inner) : base(mensagem, inner) {}
}

interface Lista<T>
{
    void InsertFirst(T objeto);                     // M√©todo para Inserir Elemento no In√≠cio da Lista
    void InsertLast(T objeto);                      // M√©todo para Inserir Elemento no Final da Lista
    void InsertAfter(T objetoRef, T objeto);        // M√©todo para Inserir Elemento Depois de Outro Elemento da Lista
    void InsertBefore(T objetoRef, T objeto);       // M√©todo para Inserir Elemento Antes de Outro Elemento da Lista
    T ReplaceElement(T objetoRef, T objeto);        // M√©todo para Substituir Elemento Antigo da Lista por Elemento Novo
    void SwapElement(T objetoRef1, T objetoRef2);   // M√©todo para Trocar Posi√ß√£o do Elemento com Outro Elemento da Lista
    T Remove(T objeto);                             // M√©todo para Remover e Retornar Elemento da Lista
    No<T> First();                                  // M√©todo para Retornar o Primeiro Elemento da Lista
    No<T> Last();                                   // M√©todo para Retornar o √öltimo Elemento da Lista
    bool InFirst(T objeto);                         // M√©todo para Verificar se Elemento est√° na Primeira Posi√ß√£o da Lista
    bool InLast(T objeto);                          // M√©todo para Verificar se Elemento est√° na √öltima Posi√ß√£o da Lista
    No<T> After(T objeto);                          // M√©todo para Retornar Elemento Posterior a Outro Elemento da Lista
    No<T> Before(T objeto);                         // M√©todo para Retornar Elemento Anterior a Outro Elemento da Lista
    int Size();                                     // M√©todo para Retornar N√∫mero de Elementos da Lista
    bool IsEmpty();                                 // M√©todo para Verificar se a Lista est√° Vazia
    No<T> Search(T objeto);                         // M√©todo para Retornar Elemento da Lista se Existir
}

class No<T>
{
    public No<T> Next {get; set;}                   // N√≥ de refer√™ncia pr√≥ximo
    public No<T> Prev {get; set;}                   // N√≥ de refer√™ncia anterior
    public T Objeto {get; set;}                     // Objeto do N√≥

    public No(T objeto = default)
    {
        Objeto = objeto;                            // Adicionando um objeto ao N√≥
        Next = Prev = null;                         // Inicializando a refer√™ncia para o pr√≥ximo e o anterior do N√≥ como NULL
    }
}

using System;

class ListaDuplamenteLigada<T> : Lista<T>
{
    private No<T> Head;                             // N√≥ Sentinela Head
    private No<T> Tail;                             // N√≥ Sentinela Tail
    private int QtdElement;                         // Quantidade de elementos da Lista

    public ListaDuplamenteLigada()
    {
        Head = new No<T>();                         // Inicializando o N√≥ Sentinela Head
        Tail = new No<T>();                         // Inicializando o N√≥ Sentinela Tail
        Head.Next = Tail;                           // Refer√™ncia do pr√≥ximo do N√≥ Head √© o N√≥ Tail
        Tail.Prev = Head;                           // Refer√™ncia do anterior do N√≥ Tail √© o N√≥ Head
        QtdElement = 0;                             // Lista est√° vazia
    }

    public void InsertFirst(T objeto)
    {
        No<T> novoNo = new No<T>();                 // Criando um novo N√≥
        novoNo.Objeto = objeto;                     // Adicionando o objeto ao N√≥
        No<T> primeiroNo = Head.Next;               // primeiro N√≥ - posterior a Head
        novoNo.Next = primeiroNo;                   // Refer√™ncia posterior do novo N√≥ √© o pr√≥ximo de Head - primeiro N√≥
        novoNo.Prev = Head;                         // Refer√™ncia anterior do novo N√≥ √© Head     
        Head.Next = novoNo;                         // Refer√™ncia posterior de Head passa a ser o novo N√≥
        primeiroNo.Prev = novoNo;                   // Refer√™ncia anterior do antigo primeiro N√≥ passa a ser o novo N√≥    
        QtdElement++;                               // Quantidade de elementos +1
    }

    public void InsertLast(T objeto)
    {
        No<T> novoNo = new No<T>();                 // Criando um novo N√≥
        novoNo.Objeto = objeto;                     // Adicionando o objeto ao N√≥
        No<T> ultimoNo = Tail.Prev;                 // √∫ltimo N√≥ - anterior a Tail
        novoNo.Next = Tail;                         // Refer√™ncia posterior do novo N√≥ √© Tail
        novoNo.Prev = ultimoNo;                     // Refer√™ncia anterior do novo N√≥ √© o anterior de Tail - √∫ltimo N√≥
        ultimoNo.Next = novoNo;                     // Refer√™ncia posterior do antigo √∫ltimo N√≥ passa a ser o novo N√≥    
        Tail.Prev = novoNo;                         // Refer√™ncia anterior de Tail passa a ser o novo N√≥
        QtdElement++;                               // Quantidade de elementos +1
    }

    public void InsertAfter(T objetoRef, T objeto)
    {
        No<T> novoNo = new No<T>();                 // Criando um novo N√≥
        novoNo.Objeto = objeto;                     // Adicionando o objeto ao N√≥
        No<T> noReferencia = Search(objetoRef);     // N√≥ de refer√™ncia para adicionar um outro N√≥ ap√≥s
        No<T> noRefNext = noReferencia.Next;        // Refer√™ncia posterior do N√≥ de refer√™ncia
        novoNo.Next = noRefNext;                    // Refer√™ncia posterior do novo N√≥ √© a refer√™ncia posterior do N√≥ de refer√™ncia
        novoNo.Prev = noReferencia;                 // Refer√™ncia anterior do novo N√≥ √© o N√≥ de refer√™ncia
        noReferencia.Next = novoNo;                 // Refer√™ncia posterior do N√≥ de refer√™ncia √© o novo N√≥
        noRefNext.Prev = novoNo;                    // Refer√™ncia anterior da antiga refer√™ncia posterior do N√≥ de refer√™ncia √© o novo N√≥
        QtdElement++;                               // Quantidade de elementos +1
    }

    public void InsertBefore(T objetoRef, T objeto)
    {
        No<T> novoNo = new No<T>();                 // Criando um novo N√≥
        novoNo.Objeto = objeto;                     // Adicionando o objeto ao N√≥
        No<T> noReferencia = Search(objetoRef);     // N√≥ de refer√™ncia para adicionar um outro N√≥ antes
        No<T> noRefPrev = noReferencia.Prev;       // Refer√™ncia anterior do N√≥ de refer√™ncia
        novoNo.Next = noReferencia;                 // Refer√™ncia posterior do novo N√≥ √© o N√≥ de refer√™ncia
        novoNo.Prev = noRefPrev;                    // Refer√™ncia anterior do novo N√≥ √© a refer√™ncia anterior do N√≥ de refer√™ncia
        noRefPrev.Next = novoNo;                    // Refer√™ncia posterior da antiga refer√™ncia anterior do N√≥ de refer√™ncia √© o novo N√≥
        noReferencia.Prev = novoNo;                 // Refer√™ncia anterior do N√≥ de refer√™ncia √© o novo N√≥
        QtdElement++;                               // Quantidade de elementos +1
    }

    public T ReplaceElement(T objetoRef, T objeto)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> novoNo = new No<T>();                     // Criando um novo N√≥
        novoNo.Objeto = objeto;                         // Adicionando o objeto ao N√≥
        No<T> noReferencia = Search(objetoRef);         // N√≥ de refer√™ncia para ser substituido pelo novo N√≥
        No<T> noRefNext = noReferencia.Next;            // Refer√™ncia posterior do N√≥ de refer√™ncia
        No<T> noRefPrev = noReferencia.Prev;            // Refer√™ncia anterior do N√≥ de refer√™ncia
        novoNo.Next = noRefNext;                        // Refer√™ncia posterior do novoNo √© a refer√™ncia posterior do N√≥ de refer√™ncia
        novoNo.Prev = noRefPrev;                        // Refer√™ncia anterior do novoNo √© a refer√™ncia anterior do N√≥ de refer√™ncia
        noRefNext.Prev = novoNo;                        // Refer√™ncia anterior da refer√™ncia posterior do N√≥ de refer√™ncia √© o novo N√≥
        noRefPrev.Next = novoNo;                        // Refer√™ncia posterior da refer√™ncia anterior do N√≥ de refer√™ncia √© o novo N√≥
        noReferencia.Next = noReferencia.Prev = null;   // Anular a refer√™ncia posterior e anterior do N√≥ que ser√° substituido 
        return noReferencia.Objeto;                     // Retorna o objeto do N√≥ de refer√™ncia
    }

    public void SwapElement(T objetoRef1, T objetoRef2)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> noRef1 = Search(objetoRef1);              // N√≥ de refer√™ncia 1 para ser trocado pelo N√≥ de refer√™ncia 2
        No<T> noRef2 = Search(objetoRef2);              // N√≥ de refer√™ncia 2 para ser trocado pelo N√≥ de refer√™ncia 1

        // CASO 1 - Mesmo N√≥
        // N√£o realizar a troca!

        if (EqualityComparer<T>.Default.Equals(objetoRef1, objetoRef2)) return; // N√£o realizar a troca se forem o mesmo N√≥

        // CASO 2 - N√≥s Adjacentes
        // 1¬∫ N√≥ possui refer√™ncia posterior no 2¬∫ N√≥   | 1¬∫ | -> | 2¬∫ |
        // 2¬∫ N√≥ possui refer√™ncia anterior no 1¬∫ N√≥    | 1¬∫ | <- | 2¬∫ |
        // OU
        // 1¬∫ N√≥ possui refer√™ncia anterior no 2¬∫ N√≥    | 2¬∫ | <- | 1¬∫ |
        // 2¬∫ N√≥ possui refer√™ncia posterior no 1¬∫ N√≥   | 2¬∫ | -> | 1¬∫ |
        // ERRO! Nesse caso, ao trocarem refer√™ncias os N√≥s podem estarem refer√™nciando eles mesmo:
        // EX.: A refer√™ncia posterior do 2¬∫ N√≥ passa a ser a refer√™ncia posterior √© o N√≥ 1¬∫: | 1¬∫ | -> | 2¬∫ | -> | 2¬∫ | -> | 2¬∫ |

        if (noRef1.Next == noRef2)                      // Verificar se N√≥ de refer√™ncia 1 √© adjacente do N√≥ de refer√™ncia 2
        {
            AdjacentElements(noRef1, noRef2);           // Realizar a troca dos N√≥ adjacentes
            return;                                     // Fim da opera√ß√£o de troca
        }
        else if (noRef2.Next == noRef1)                 // Verificar se N√≥ de refer√™ncia 2 √© adjacente do N√≥ de refer√™ncia 1
        {
            AdjacentElements(noRef2, noRef1);           // Realizar a troca dos N√≥ adjacentes
            return;                                     // Fim da opera√ß√£o de troca
        }

        // CASO 3 - N√≥s n√£o Adjacentes
        // Realiza√ß√£o de troca padr√£o!

        No<T> next1 = noRef1.Next;                      // Refer√™ncia posterior do N√≥ de refer√™ncia 1
        No<T> prev1 = noRef1.Prev;                      // Refer√™ncia anterior do N√≥ de refer√™ncia 1
        No<T> next2 = noRef2.Next;                      // Refer√™ncia posterior do N√≥ de refer√™ncia 2
        No<T> prev2 = noRef2.Prev;                      // Refer√™ncia anterior do N√≥ de refer√™ncia 2
        next1.Prev = noRef2;                            // A refer√™ncia anterior da refer√™ncia posterior do N√≥ de refer√™ncia 1 √© N√≥ de refer√™ncia 2
        prev1.Next = noRef2;                            // A refer√™ncia posterior da refer√™ncia anterior do N√≥ de refer√™ncia 1 √© N√≥ de refer√™ncia 2
        next2.Prev = noRef1;                            // A refer√™ncia anterior da refer√™ncia posterior do N√≥ de refer√™ncia 2 √© N√≥ de refer√™ncia 1
        prev2.Next = noRef1;                            // A refer√™ncia posterior da refer√™ncia anterior do N√≥ de refer√™ncia 2 √© N√≥ de refer√™ncia 1
        (noRef1.Next, noRef2.Next) = (next2, next1);    // Trocar as refer√™ncias dos posteriores dos N√≥s de refer√™ncia entre s√≠
        (noRef1.Prev, noRef2.Prev) = (prev2, prev1);    // Trocar as refer√™ncias dos anteriores dos N√≥s de refer√™ncia entre s√≠
    }

    private void AdjacentElements(No<T> noRef1, No<T> noRef2)
    {
        No<T> next = noRef2.Next;                   // Refer√™ncia posterior do N√≥ de refer√™ncia 2
        No<T> prev = noRef1.Prev;                   // Refer√™ncia anterior do N√≥ de refer√™ncia 1
        prev.Next = noRef2;                         // Refer√™ncia posterior da refer√™ncia anterior do N√≥ de refer√™ncia 1 passa a ser N√≥ de refer√™ncia 2 
        noRef2.Next = noRef1;                       // Refer√™ncia posterior do N√≥ de refer√™ncia 2 √© N√≥ de refer√™ncia 1
        noRef2.Prev = prev;                         // Refer√™ncia anterior do N√≥ de refer√™ncia 2 √© refer√™ncia anterior do N√≥ de refer√™ncia 1                        
        noRef1.Next = next;                         // Refer√™ncia posterior do N√≥ de refer√™ncia 1 √© refer√™ncia posterior do N√≥ de refer√™ncia 2                        
        noRef1.Prev = noRef2;                       // Refer√™ncia anterior do N√≥ de refer√™ncia 1 √© N√≥ de refer√™ncia 2
        next.Prev = noRef1;                         // Refer√™ncia anterior da refer√™ncia posterior do N√≥ de refer√™ncia 2 passa a ser N√≥ de refer√™ncia 1
    }

    public T Remove(T objeto)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> noRemovido = Search(objeto);              // Encontrar o N√≥ que ser√° removido
        No<T> noRemoveNext = noRemovido.Next;           // Refer√™ncia posterior do N√≥ que ser√° removido
        No<T> noRemovePrev = noRemovido.Prev;           // Refer√™ncia anterior do N√≥ que ser√° removido
        noRemoveNext.Prev = noRemovePrev;               // Refer√™ncia anterior da refer√™ncia posterior do N√≥ que ser√° removido √© a refer√™ncia anterior do N√≥ que ser√° removido
        noRemovePrev.Next = noRemoveNext;               // Refer√™ncia posterior da refer√™ncia anterior do N√≥ que ser√° removido √© a refer√™ncia posterior do N√≥ que ser√° removido
        noRemovido.Next = noRemovido.Prev = null;       // Anular a refer√™ncia posterior e anterior do N√≥ que ser√° removido
        QtdElement--;                                   // Quantidade de elementos -1
        return noRemovido.Objeto;                       // Retorna o elemento do N√≥ que ser√° removido
    }

    public No<T> First()
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        return Head.Next;                               // Retorna o primeiro N√≥ da Lista
    }

    public No<T> Last()
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        return Tail.Prev;                               // Retorna o √∫ltimo N√≥ da Lista
    }

    public bool InFirst(T objeto)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> noReferencia = Search(objeto);            // N√≥ de refer√™ncia que quer saber se est√° no inicio da Lista
        bool inFirst = false;                           // V√°riavel auxiliar para saber se o N√≥ de refer√™ncia est√° no inicio da Lista
        if (Head.Next == noReferencia) inFirst = true;  // Verifica√ß√£o para saber se o N√≥ de refer√™ncia est√° no inicio da Lista
        return inFirst;                                 // Retorna a reposta - TRUE ou FALSE - se o N√≥ de refer√™ncia est√° no inicio da Lista
    }

    public bool InLast(T objeto)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> noReferencia = Search(objeto);            // N√≥ de refer√™ncia que quer saber se est√° no final da Lista
        bool inLast = false;                            // V√°riavel auxiliar para saber se o N√≥ de refer√™ncia est√° no final da Lista
        if (Tail.Prev == noReferencia) inLast = true;   // Verifica√ß√£o para saber se o N√≥ de refer√™ncia est√° no final da Lista
        return inLast;                                  // Retorna a reposta - TRUE ou FALSE - se o N√≥ de refer√™ncia est√° no final da Lista
    }

    public No<T> After(T objeto)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> noReferencia = Search(objeto);            // N√≥ de refer√™ncia para encontrar o pr√≥ximo N√≥ a ele
        return noReferencia.Next;                       // Retorna o pr√≥ximo N√≥ ao N√≥ de refer√™ncia
    }

    public No<T> Before(T objeto)
    {
        if (IsEmpty()) throw new ListaVaziaExcecao();   // Verificar se a Lista est√° vazia
        No<T> noReferencia = Search(objeto);            // N√≥ de refer√™ncia para encontrar o N√≥ anterior a ele
        return noReferencia.Prev;                       // Retorna o N√≥ anterior ao N√≥ de refer√™ncia
    }

    public int Size()
    {
        return QtdElement;                              // Retorna a quantidade de N√≥s da Lista
    }

    public bool IsEmpty()
    {
        return Head.Next == Tail;                       // Verificar se a Lista est√° vazia
    }

    public No<T> Search(T objeto)
    {
        No<T> atualNo = Head;                                                                                       // Conseguir uma refer√™ncia auxiliar do come√ßo da Lista
        while (!EqualityComparer<T>.Default.Equals(atualNo.Objeto, objeto))
        {
            atualNo = atualNo.Next;                                                                                 // Encontra o N√≥ que possui o elemento
        }
        if (!EqualityComparer<T>.Default.Equals(atualNo.Objeto, objeto)) throw new ObjetoNaoEncontradoExcecao();     // Verificar se existi o N√≥ com o elemento na Lista
        return atualNo;
    }
}
```
